package recursion;

public class Main {
    public static void main(String[] args) {

//      Рекурсія - здатність методів викликати самих себе.
//      Розглянемо приклад: у нас буде метод, який називатиметься foo, він буде void і буде виводити "Hello"
//      Якщо ми викличемо його у main() методі 1 раз нам спокійно виведеться "Hello" у консолі, але якщо ми його викличемо
//      самого себе у методі foo то получиться наступна ситуація: в методі foo() буде ще один той самий метод, який виклиає
//      себе самого в середині якого така ж сама ситуація. І коли ми тільки оголосили метод foo(), він не закінчить свою
//      роботу, поки вкладені методи не завершуться. Кожен внутрішній метод зупиняє життєвий цикл зовнішнього метода.
//      Якщо ми це викличемо, буде помилка StackOverflow - наший стек переповнений. Це означає, що нові методи народжуються,
//      але старі методи не закінчуються і не звільнюють пам'ять.

        foo();
        increment(0);

        int[] numbers = { 12,23,34 };
        iterateArrayRecursion(0, numbers);

    }

    public static void foo() {
        System.out.println("Hello");
        foo(); // Тут буде рекурсія
    }

//     Давайде напишемо функцію інкремента, без застосування цикла, із використанням рекурсії

    public static void increment(int index) {
        index++;
        System.out.println(index);
        if (index >= 5) {
            return;
        }
        increment(index);
    }

//      Або давайте спробуємо проітерувати масив використовуючи рекурсію
//      Якщо ми не зробимо умови виходу з рекурсії нам впаде помилка, тому що коли ми вивели 3 елементи масиву, у нас
//      нічого не зупиняється і продовжується працювати дальше

    public static void iterateArrayRecursion(int index, int[] array) {
        System.out.println(array[index]);
        index++;
        if (index >= array.length) {
            return;
        }
        iterateArrayRecursion(index, array);
    }

}