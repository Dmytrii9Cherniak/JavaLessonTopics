package OOP;

public class Person {

//  Java не підтримує множинне наслідування.

//  Завдяки чотирьом модифікаторів досутпу, ми досягаємо інкапсуляції
//  private: якщо метод чи поле є приватним, доступитися ми можемо лише із поточного класу,
//  protected: доступитися можемо лише через класи - нащадки,
//  public: поле доступне всім,
//  default: ми можемо доступитися ще класи, які знаходяться в поточному пакеті

    private int id;
    private String name;
    private int age;

//  Ключове слово static нам говорить те, що позначене цим словом (змінна чи метод) завантажується одразу же в оперативну пам'ять.
//  Static може бути або змінна або метод. Яка різниця між простим і статичним методом? До нестатичного методу, ми можемо
//  доступитися лише із об'єкту, ми повинні створити об'єкт класу Person щоб мати доступ до його полів і до його методів класу.
//  Статичний метод не обов'язково хоче об'єкт. Все завантажується в оперативну пам'ять із всією інформаціює про клас.

//  Однак у нас є певні обмеження. Ми не можемо в статичному методі викликати не статичні методи. Коли ми пишемо код всередині
//  нестатичного метода, компілятор знає що ми викликаємо цей метод вже із створеного екземпляру класу тому що ми не
//  можемо викликати не статичний метод класу не створивши об'єкт цього класу. Відповідно, всередині цього метода можемо
//  викликати інші методи класу, тому що по-дефолту вони теж існують в пам'яті.   Статичний метод не знає чи ми створили
//  об'єкт. Він одразу завантажується в пам'ять і що відбувається потім, він не знає. Статичні методи мають доступ лише
//  до статичного контенту. Не статичні методи мають доступ до всього

    //  Статична змінна а належить класу, тому одночасно вона належить і всім об'єктам, тому це не створюється копія статичного
//  класу для статичного поля на кожен об'єкт. Це єдиний оригінал і всі мають до цього доступ.
    static int a;

//  Java у собі має ще одне ключове слово, яке називається final. Це слово ми можемо писати до багатьох речей. По-перше,
//  ми можемо сказати, що наш клас може бути фінальним (final class Person). Це означає, що цей клас не може бути наслідувати.
//  По-друге, фінальним може бути і метод (public final void method()). Це означає, що ми не можемо зробити Override методу
//  цього. Бажано писати завжди final то класів, методів, полів, якщо вони не будуть успадкоуватися, переписуватися, змінюватися.
//  Зробити поле приватним - це означає, що воно буде обов'язково ініціалізуватися при створені об'єкту.
//  І як ми сказали, що поле може бути final. Це означає, що ми не можемо поміняти значення цієї змінної.
//  Фінальним може бути і локальна змінна. Якщо ми присвоїли змінній певне значення, поміняти значення ми не зможемо
//  Тобто final, це звичайні константи. Але не треба думати, що якщо поле є фінальним, це поле не буде успадковуватися
//  класам нащадкам.

//  Дефолтний конструктор - конструктор без параметрів. Він є присутній по-замовчуваню у будь-якому класі. Конструктори
//  не наслідуються
//  Наший клас Student має все те саме, що і клас Person. Він має всі ті самі методи, що і Person. Однак, якщо ми зробимо
//  один із методів приватим, у нашому випадку getter або setter, у Student він видний не буде і доступитися ми не зможемо.
//  Цей метод стає hidden. Чи успадковуються приватні елементи класу? Так, але вони є приховані. В Java ми не можемо
//  створити метод поза межами класу. Якщо ми поле id зробимо фінальною (private final int id), у нас на setter поле id
//  буде падати помилка, тому що сеттер для фінальної змінної це непотрібна річ

    public Person() {}

    public Person(int id, String name, int age) {
        this.id = id;
        this.name = name;
        this.age = age;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

//  За допомогою наслідування, ми можемо робити Override методів - переписувати методи. Коли ми викликаємо ці методи
//  для класу батька і нащадка ( p.method(), s.method ), цей метод спрацює одинаково для обох. Тому що у Person цей метод
//  має дефолтне налаштування, Student його успадкував і вивелися вони одинаково.

//  Наслідування нам допомагає працювати із певною кількістью об'єктів, одного типу, як із єдиним цілим. Для прикладу,ми
//  створили ще один клас Worker. У Main класі, ми створили масив person. Student i worker також являється Person, це і значить
//  робота із єдиним цілим. Якщо ми для масиву, замість Person поставимо Student, буде помилка, тому що лише Student є Student(ом)
//  Тому у нас є загальний клас Person, від якого успадковуються усі решта класи і ті всі решта класів можемо зв'язати в
//  одне ціле. Тому, коли ми проходимося циклом по-масиву, ми можемо всім викликати даний метод з різною поведінкою (виводом)

    public void method() {
        System.out.println("I am a person");
    }

//  В Java ще існує така річ, яка називається Overload - перегрузка метода. Це тоді коли в межах одного класу, ми маємо метод,
//  з одинаковою назвою, але різними параметрами

//  Не потрібно плутати Override i Overload. Override - коли клас нащадок хоче переписати метод класу батька.
//  Override дуже є корисним при поліморфізмі, коли викликали метод у циклі при переході між об'єктами класу Person.
//  Наш метод набирав форму.
//  Override реалізує динамічний поліморфізм. Тому що зміни відбувалися в runtime. Для прикладу, у нас є 3 створених об'єкти,
//  а їх може бути десь 100 і ми не знаємо, що у нас буде очікуватися в консолі, ми не знаємо, що і який об'єкт буде що
//  викликати. Це все відбувається під час роботи нашої програми (runtime) і ми вже бачимо, якої форми цей метод набуває.
//  Тому це і називається динамічний поліморфізм.

//  A Overload називається статичним, тому що метод один і той самий, але тіло метода різне і ми знаємо, що коли ми викли-
//  чемо метод із параметром, він виконається як треба, але технічно метод має одну і ту саму назву. Він набуває певної
//  форми, але ми знаємо це наперед. Тому overload реалізовує статичний поліморфізм.

//  Але є у нас певні обмеження. При Override ми не можемо змінювати сигнатуру метода - все, що йде до фігурної дужки.
//  Це модифікатори доступу, тип повернення. І не можемо міняти параметри. Override має на мені зміну лише тіла метода.
//  Вхідні параметри, назву, тип повернення, модифікатори, параметри він не міняє.

//  При Overload навпаки, тому що ми мусимо міняти вхідні параметри. Ми можемо міняти кількість вхідних параметрів, ми
//  можемо міняти тип вхідних параметрів.
    public void method(String string) {
        System.out.println(string + "from person");
    }

    public void method(int number) {
        System.out.println(number + "from person");
    }

    public void method(boolean status) {
        System.out.println(status + "from person");
    }

    public static void staticMethod() {
//        this.setAge();  // Тут буде помилка
        System.out.println("static method");
    }

    @Override
    public String toString() {
        return "Person{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

}
